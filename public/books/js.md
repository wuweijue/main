1.内存空间：<br />1.代码空间：存储可执行的代码<br />2.堆空间：键值对的形式，存储引用数据类型的值<br />3.栈空间：栈结构，后进先出，存储基本数据类型和引用数据类型在堆中的地址<br />4.垃圾回收机制：<br />1.内存分类：基于世代假说，即新生对象倾向于早死，不死的对象活得更久<br />1.新生代：新生成或只经过一次垃圾回收的对象，由两个空间组成，每个最大 16M<br />2.老生代：经过一次以上垃圾回收的对象，最大 1.4G<br />2.拾荒算法：适用于新生代内存<br />1.将堆空间一分为二，一个为 to 闲置空间，一个为 from 工作空间<br />2.从 from 中分配对象，若空间占满，则进行垃圾回收<br />3.检查 from 中的对象，若对象存活，判断是否符合晋升条件<br />1.对象是否经历过一次回收<br />2.to 空间内存使用占比超过限制<br />4.若符合则升为老生代，否则复制进 to，不存活则释放空间<br />5.结束后将 from 与 to 交换<br />3.引用计数：计算资源被引用的次数，当次数变为 0 时，则释放空间（未使用）<br />4.标记清除：垃圾回收的主要方法<br />1.遍历堆中所有对象，对存活对象进行标记<br />2.对未标记的对象空间进行回收<br />3.速度快但会造成内存空间不连续，影响后续内存分配<br />6.标记整理：<br />1.在标记清除的算法上改进，但速度慢，仅在空间内存分配不足时使用<br />2.将存活的对象移动到一边，再清理边界外的内存<br />6.全停顿：为避免与代码逻辑不一致，垃圾回收器在执行期间将暂停代码执行，但时间过长会导致卡顿，为了减少全停顿的优化：<br />1.增量标记：将停顿进行的标记工作分步，与 js 代码交替执行<br />2.延迟清理：允许垃圾回收器在标记完成之后，需要时再异步进行清理工作，将垃圾回收的停顿分散在各个时间段内<br />5.内存泄漏：变量占据的内存无法回收<br />1.全局变量<br />2.闭包<br />3.定时器<br />4.事件监听器<br />5.dom 元素

2.执行上下文：当前代码的运行环境<br />1.调用栈（执行上下文栈）：存储当前代码执行所需要的运行环境<br />1.分类：<br />1.全局执行上下文<br />2.函数执行上下文<br />3.模块执行上下文：各个模块内部独立的执行上下文<br />4.eval 执行上下文：eval 内部独立的执行上下文<br />2.执行步骤：<br />1.代码执行时，全局执行上下文入栈<br />2.当模块被导入时，创建模块全局上下文并入栈<br />3.执行到某函数时，函数上下文入栈<br />4.当函数执行结束，函数上下文出栈<br />5.当模块执行完毕后，模块上下文出栈<br />6.同步代码执行结束，全局上下文出栈<br />2.执行上下文内容：<br />1.ES3 版本：<br />1.变量对象（创建阶段）：此时会发生声明提前<br />1.检索当前参数，生成 arguments 属性，以及以形参名为 key 的属性<br />1.arguments<br />2.caller：函数本身<br />2.检索当前上下文中的变量声明，生成以变量名为 key ，value 为 undefined 的属性<br />3.检索当前上下文中的函数声明，生成以函数名为 key ，value 为函数索引地址的属性<br />2.活动对象（执行阶段）：此时变量属性将被赋值<br />3.作用域链（scope chain）：当函数声明时，将会保存当前环境下的执行上下文的变量对象至 scope 属性中，当该函数执行时，再将其加入作用域链中，作用域链由当前上下文和上层上下文的变量对象组成，访问时，将沿作用域链由内而外检索声明标识符，直至全局作用域<br />2.ES5 版本：<br />1.词法环境组件：即作用域的实现，用于解析标识符，控制它们的访问权限<br />2.变量环境组件：存储了执行时所需要的变量和函数的引用，类似于活动对象<br />3.二者的区别：<br />1.变量环境组件也是词法环境，它们初始时拥有相同的值<br />1.但词法环境可能改变，例如进入块级作用域，因此 let 和 const 的声明不会被记录在变量环境内<br />2.而变量环境在执行过程中永远不会改变，所以 var 和 function 的声明被存储在变量环境内<br />3.词法环境组成：<br />1.外部环境引用：即作用域链上的外部作用域<br />2.环境记录器：存储变量和函数声明的实际地址<br />1.声明式环境记录：<br />1.存储内容：用于存储变量和函数声明<br />2.创建方式：通常在进入新的词法环境（函数或块级作用域）时创建<br />3.访问方式：通过标识符访问<br />2.对象环境记录：<br />1.存储内容：用于存储全局对象属性和 with 语句<br />2.创建方式：通过对象创建，例如通过 var 创建的全局属性<br />3.访问方式：通过访问对象属性名访问<br />3.函数环境记录：特殊的声明性函数记录<br />1.存储内容：在原有基础上加入了 this 和 arguments 对象<br />2.创建方式：在函数调用时创建<br />4.模块环境记录：特殊的声明性函数记录<br />1.存储内容：在原有基础上加入了 export 对象<br />2.创建方式：在模块加载并执行时创建<br />2.不可变的绑定：即 import 无法重新赋值的原因<br />3.二者共用：<br />1.arguments 参数：动态属性，只能在函数内部访问<br />1.具备迭代器的伪数组<br />2.length 属性的值是实参的数量而非形参<br />3.callee 属性即函数本身，可以通过调用 callee 实现递归，严格模式无法使用<br />4.非严格模式下，修改 arguments 中的值会修改参数，严格模式下则不会<br />2.caller：函数本身，严格模式无法使用<br />3.this 指针：类似于动态作用域，this 指针在不同调用环境下指向有所不同<br />1.全局作用域或自我调用的函数中：<br />1.严格模式：undefined<br />2.非严格模式：window<br />2.构造函数：指向新生成的对象<br />3.显式绑定：通过 bind，call，apply 的第一个参数修改指向<br />4.隐式绑定：调用该函数的对象，多层对象中指最接近的那个属性<br />5.箭头函数：箭头函数内不存在this，会引用外层的 this

3.作用域：程序设置的一套规则，它负责收集和维护所有对声明标识符的查询，并实施一套标准来确定访问权限

4.闭包：<br />1.概念：能访问到另一个函数作用域的函数<br />2.原理：<br />1.由于 js 使用词法作用域，在函数声明时，已将声明环境上下文的变量对象保存，等到执行时，再加入作用域链，因而嵌套内部的函数执行时可以沿着作用域链访问到外部作用域<br />2.通常函数执行结束后，其内部的执行上下文将会出栈，空间被回收，但被内部函数使用的外部变量将持续处于活跃状态，因此不会被垃圾回收<br />2.用途：变量和参数缓存<br />1.创建 promise 对象<br />2.高阶函数<br />3.函数柯里化：部分求值，每一次接收一个参数，并返回一个函数以供接收下一个参数，并将当前的结果通过闭包缓存，提供给下一个使用

5.js 面向对象：将客观世界的实体抽象化<br />1.封装：将一段描述对象属性和方法的代码组合，封装在一个类中，使用者只需要知道对外的接口，而无需了解内部如何实现，体现了程序的复用性和易用性<br />2.继承：体现在多个类之间的联系与区别，子类可以通过继承获取父类的方法与属性，从而提升代码复用性<br />3.多态：在继承的前提下，子类不仅可以继承父类的属性和方法，亦可对其重载，修改原有的属性和方法，扩展更多特性

6.原型与原型链：js 中所有对象都拥有 **proto** 指针指向其原型对象，从而形成原型链，原型链最终会指向 Object.**proto** 即 null，当访问实例对象的属性时，如果对象本身不存在某个属性，则会沿着原型链检索，直到找到该属性或是到原型链尽头为止

7.继承方式：<br />1.寄生组合式继承（与 class 的 extends 基本相同），是原型链继承和构造函数继承的组合的优化
```javascript
function Parent (name){
    this.name = name;
    this.transport = ()=>{
    	console.log('car')
    }
}

function Child(name){
    // 构造函数式继承，在子类构造函数中调用父类构造函数，从而获得父类属性和方法
    Parent.call(this); 
    this.name = name;
}

// 原型式继承，将子类原型对象 __proto__ 指向父类原型对象的实例
Child.prototype = Object.create(Parent.prototype) 

```
2.super：本身其实是构造函数继承的语法糖<br />1.super 作为函数使用时，指向父类的构造函数<br />2.super 作为对象使用时，指向父类的原型对象<br />3.如果子类不存在构造函数，会默认自动执行 super 方法

8.new 构造函数的过程<br />1.分配一块内存堆空间，创建一个空对象<br />2.将该对象的 **proto** 指向构造函数的 prototype<br />3.将构造函数的 this 指向该对象，并执行构造函数<br />4.返回新对象：<br />1.如果构造函数没有返回值，则返回该对象<br />2.如果构造函数返回的是基本数据类型，则返回该对象<br />3.如果构造函数返回的是引用数据类型，则返回该值

9.浏览器事件循环：<br />1.概念：js 是一门单线程语言，在同一时间内只能做一件事，为了避免等待造成的阻塞，会将等待的任务挂起，等到执行时机再异步执行，而异步任务执行后又可能产生新的异步任务，js 引擎需要协调和管理各种异步任务的执行顺序<br />2.事件循环流程<br />1.同步任务进行执行栈<br />2.如果是同步任务进入主线程直接执行<br />3.异步任务则暂时挂起，等待到达执行时机再加入任务队列，宏任务与微任务分别加入各自的队列<br />4.同步任务执行完毕，依次执行微任务队列的任务，直至完全清空<br />5.执行第一个宏任务，执行完毕后检查微任务队列，如果存在任务，则依次执行微任务队列的任务，直至队列清空<br />6.以此循环，直至最后一个宏任务执行完毕<br />3.宏任务：<br />1.计时器线程任务<br />2.DOM 事件，包括 messageChannel<br />3.ajax 事件<br />4.requestAnimationFrame 绘制前执行动画的回调<br />4.微任务：<br />1.queueMicrotask：手动添加微任务<br />2.promise<br />3.MutationObserver：dom 树监听<br />4.Proxy get：监听对象行为<br />5.Generator 生成器

10.事件流：捕获与冒泡行为<br />1.概念：当事件发生在元素节点之间，会以特定的顺序进行传播，这个过程就是事件流<br />2.事件流顺序：<br />1.捕获阶段：从根节点至目标元素<br />2.当前目标阶段<br />3.冒泡阶段：从目标元素至根节点<br />3.使用：<br />1.js 只能执行捕获与冒泡其中一个阶段<br />2.onclick 与 addEvent 只能执行冒泡阶段<br />3.addEventListener 第三个参数如果为 true 则执行捕获阶段<br />4.部分事件不存在冒泡：<br />1.onblur，onfocus<br />2.onmouseenter ，onmouseleave 等<br />4.阻止事件冒泡：<br />1.常用浏览器：<br />1.e.stopPropagation：阻止当前事件向父级元素冒泡<br />2.e.stopImmediatePropagtion：阻止所有同类事件向父级冒泡，适用于给同个元素添加了多个同类型事件的事件监听器 <br />2.ie：window.event.cancelBubble = true<br />5.事件委托：<br />1.原理：因为冒泡的缘故，将子元素的监听绑定在父元素上，也能执行回调，可以通过 e.target 判断是否是目标元素决定是否执行操作<br />2.优点：当存在很多子元素时，绑定在父元素上可以减少监听器的数量，提升性能<br />6.阻止默认行为：<br />1.event.preventDefault 全部支持<br />2.event.returnValue = false 该方法已从标准中移除<br />3.return false 不建议滥用

11.函数式编程：<br />1.特性：<br />1.函数是一等公民，与其它数据类型相同，可以赋值给变量，赋值给参数<br />2.只使用有返回值的表达式，不用无返回值的语句<br />3.无副作用，即与外部不产生互动，不产生运算以外的结果<br />4.惰性求值：将表达式赋值给变量时，并不计算变量的值，而是当变量第一次使用时才进行计算，避免不必要的求值<br />5.引用透明：函数的运行不依赖于外部变量，只依赖参数，保证输入相同时，输出的结果永远相同<br />6.无锁并发：由于函数式编程不修改外部变量，所以不需要担心死锁，即一个线程的数据被另一个线程修改，所以可以分摊到多个线程，部署并发<br />2.常用的函数式编程：<br />1.函数柯里化：将多元函数转换为依次调用的单元函数<br />2.函数组合：<br />1.命令式：a(b(c()))<br />2.面向对象：a().b().c()<br />3.函数式：compose(a,b,c)<br />3.高阶函数：接收一个函数作为参数，再返回一个函数<br />4.react hooks<br />5.redux

12.node 事件循环：<br />1.原理：<br />1.nodejs 在主线程内维护了一个事件队列，当接到请求后，就将该请求作为事件放入队列，然后继续接收其他请求<br />2.当主线程空闲时，即没有请求接入时，开始事件循环，检查队列中是否有要处理的事件<br />3.如果是非 i/o 任务，就主线程亲自处理，并通过回调函数返回到上层调用<br />4.如果是 i/o 任务，就从线程池取一个线程处理该事件，并指定回调函数，然后继续执行循环内的其它事件<br />5.当线程的 i/o 任务完成后，执行回调函数，并把这个完成的事件放入事件队列尾部，等待事件循环，当主线程再次循环到该事件时，就直接处理并返回给上层调用<br />2.node 线程：仅 js 运行在单线程中，但 nodejs 本身是支持多线程的<br />3.事件循环的阶段顺序：<br />1.timers 定时器检查阶段：检查队列中是否存在到期的 setTimeout 和 setInterval，并执行回调<br />2.pending callbacks io 事件处理阶段：检查是否存在 pending 的 i/o 回调，并执行<br />3.idle，prepare 闲置阶段：仅 nodejs 内部使用<br />4.poll 轮询阶段：检查是否存在尚未完成的回调，如果存在分以下两种情况<br />1.如果存在可用回调，执行所有可用回调<br />2.检查是否有 setImmediate 回调，如果有则退出 poll 阶段，没有则阻塞在此，等待新事件<br />5.check 检查阶段：执行 setImmediate 的回调<br />6.close callback 关闭事件阶段：执行各种 close 的回调，例如 socket，流结束<br />4.宏任务与微任务<br />1.事件循环中的每个阶段执行的事件队列内的事务都是宏任务<br />1.setImmediate 的回调函数将在事件循环的末尾执行<br />2.事件循环的每个子阶段的末尾将执行所有的微任务，清空微任务队列，按以下顺序<br />1.process.nextTick<br />2.其它微任务，例如 promise<br />5.与浏览器事件循环的区别：<br />1.nodejs 中微任务在事件循环的各个子阶段的末尾执行<br />2.浏览器的微任务在执行一个宏任务之后执行



